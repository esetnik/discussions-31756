# cspell:word elif,circleci,cimg,xlarge
version: 2.1
parameters:
  GHA_Actor:
    type: string
    default: ""
  GHA_Action:
    type: string
    default: ""
  GHA_Event:
    type: string
    default: ""
  GHA_Meta:
    type: string
    default: ""
aliases:
  # Shallow Clone
  - &checkout-shallow
    name: Checkout
    command: |
      #!/bin/sh
      set -e

      # Workaround old docker images with incorrect $HOME
      # check https://github.com/docker/docker/issues/2968 for details
      if [ "${HOME}" = "/" ]
      then
        # cspell:word getent passwd
        export HOME=$(getent passwd $(id -un) | cut -d: -f6)
      fi

      # cspell:word mkdir
      mkdir -p ~/.ssh

      # Obtain github.com ssh public keys and add to known_hosts
      curl -L https://api.github.com/meta | jq -r '.ssh_keys | .[]' | sed -e 's/^/github.com /' >> ~/.ssh/known_hosts

      # cspell:word umask, chmod
      (umask 077; touch ~/.ssh/id_rsa)
      chmod 0600 ~/.ssh/id_rsa
      (cat \<<EOF > ~/.ssh/id_rsa
      $CHECKOUT_KEY
      EOF
      )

      # use git+ssh instead of https
      git config --global url."ssh://git@github.com".insteadOf "https://github.com" || true

      if [ -e ~/prodigy/.git ]
      then
          cd ~/prodigy
          git remote set-url origin "$CIRCLE_REPOSITORY_URL" || true
      else
          mkdir -p ~/prodigy
          cd ~/prodigy
          git clone --depth=1 "$CIRCLE_REPOSITORY_URL" .
      fi

      if [ -n "$CIRCLE_TAG" ]
      then
        git fetch --depth=10 --force origin "refs/tags/${CIRCLE_TAG}"
      elif [[ "$CIRCLE_BRANCH" =~ ^pull\/* ]]
      then
      # For PR from Fork
        git fetch --depth=10 --force origin "$CIRCLE_BRANCH/head:remotes/origin/$CIRCLE_BRANCH"
      else
        git fetch --depth=10 --force origin "$CIRCLE_BRANCH:remotes/origin/$CIRCLE_BRANCH"
      fi

      if [ -n "$CIRCLE_TAG" ]
      then
          git reset --hard "$CIRCLE_SHA1"
          git checkout -q "$CIRCLE_TAG"
      elif [ -n "$CIRCLE_BRANCH" ]
      then
          git reset --hard "$CIRCLE_SHA1"
          git checkout -q -B "$CIRCLE_BRANCH"
      fi

      git reset --hard "$CIRCLE_SHA1"

yarn-install: &yarn-install
  run:
    name: yarn install
    command: |
      for i in $(seq 1 5); do \
      yarn install --frozen-lockfile --cache-folder ~/.cache/yarn \
      && s=0 && break || s=$? && sleep 10; done; (exit $s)
    working_directory: ~/prodigy/frontend

yarn-install-unicorn: &yarn-install-unicorn
  run:
    name: yarn install
    command: |
      for i in $(seq 1 5); do \
      yarn install --frozen-lockfile --cache-folder ~/.cache/yarn \
      && s=0 && break || s=$? && sleep 10; done; (exit $s)
    working_directory: ~/prodigy/node

restore-cache: &restore-cache
  restore_cache:
    keys:
      - v1-repo-{{ .Environment.CIRCLE_BRANCH}}-{{ .Environment.CIRCLE_SHA1 }}

restore-eslint-cache: &restore-eslint-cache
  restore_cache:
    name: Restore eslint cache
    keys:
      - &eslint-cache v1-eslintcache-{{ .Environment.CIRCLE_BRANCH}}-{{ .Environment.CIRCLE_SHA1 }}
      - v1-eslintcache-{{ .Environment.CIRCLE_BRANCH}}
      - v1-eslintcache-

save-eslint-cache: &save-eslint-cache
  save_cache:
    name: Save eslint cache
    key: *eslint-cache
    paths:
      - frontend/.eslintcache

restore-cspell-cache: &restore-cspell-cache
  restore_cache:
    name: Restore cspell cache
    keys:
      - &cspell-cache v1-cspellcache-{{ .Environment.CIRCLE_BRANCH}}-{{ .Environment.CIRCLE_SHA1 }}
      - v1-cspellcache-{{ .Environment.CIRCLE_BRANCH}}
      - v1-cspellcache

save-cspell-cache: &save-cspell-cache
  save_cache:
    name: Save cspell cache
    key: *cspell-cache
    paths:
      - .cspellcache

ecs-cli-configure: &ecs-cli-configure
  run:
    name: ecs-cli configure
    command: |
      ecs-cli configure --cluster ${ECS_CLUSTER_NAME} \
        --region ${AWS_REGION} \
        --default-launch-type FARGATE \
        --config-name prodigy_cluster_config

ecr-get-login: &ecr-get-login
  run:
    name: aws ecr get-login-password
    command: |
      for i in $(seq 1 5); do aws ecr get-login-password \
        | docker login \
        --username AWS \
        --password-stdin \
      ${ECR_ENDPOINT} && s=0 && break || s=$? && sleep 10; done; (exit $s)

build-image: &build-image
  run:
    name: Build ${IMAGE_NAME} image
    command: |
      for i in $(seq 1 5); do \
        docker compose \
          --compatibility \
          --verbose \
          -f docker-compose.yml \
          -f docker-compose-e2e.yml \
          build ${IMAGE_NAME} \
          --build-arg BUILDKIT_INLINE_CACHE=1 \
          --progress plain \
      && s=0 && break || s=$? && sleep 10; done; (exit $s)

push-image: &push-image
  run:
    name: Push ${IMAGE_NAME} image
    command: |
      ECR_IMAGE_TAG=${ECR_ENDPOINT}/prodigy_${IMAGE_NAME}
      echo pushing image "${ECR_IMAGE_TAG}:${CIRCLE_SHA1}" to registry
      docker tag prodigy_${IMAGE_NAME} ${ECR_IMAGE_TAG}:${CIRCLE_SHA1}
      docker tag prodigy_${IMAGE_NAME} ${ECR_IMAGE_TAG}:latest
      docker push ${ECR_IMAGE_TAG}:latest | cat
      docker push ${ECR_IMAGE_TAG}:${CIRCLE_SHA1} | cat

build_docker: &build-docker
  working_directory: /home/circleci/prodigy
  executor: prodigyems-docker
  environment:
    DOCKER_BUILDKIT: 1
    COMPOSE_DOCKER_CLI_BUILD: 1
  steps:
    - *restore-cache
    - setup_remote_docker:
        docker_layer_caching: false
        version: default
    - *ecr-get-login
    - *build-image
    - *push-image

deploy-requires: &deploy-requires
  requires:
    - test_e2e
    - test_frontend

build-requires: &build-requires
  requires:
    - lint_web
    - lint_unicorn
    - lint_frontend
    - test_frontend

docker-container: &docker-container
  executor: prodigyems-docker
  working_directory: /home/circleci/prodigy

migrate: &migrate
  <<: *docker-container
  steps:
    - <<: *restore-cache
    - <<: *ecs-cli-configure
    - run:
        name: Run migrate on ECS fargate
        command: |
          # add -u option to fail on uninitialized variables
          set -euo pipefail
          ecs-cli compose \
            --debug \
            --project-name migrate \
            --file docker-compose-ecs-migrate.yml \
            --ecs-params ecs-params-${ENV}-migrate.yml \
            start \
            --cluster-config prodigy_cluster_config \
            --create-log-groups | tee ecs_output.txt

          # Extract the TASK_ID from the saved output using awk
          TASK_ID=$(awk -F'/' '/Starting container.../ {print $2}' ecs_output.txt)
          echo "Extracted TASK_ID: $TASK_ID"

          SUCCESS_LOG_FOUND=0  # A flag to check if the desired log output is found
          TIMEOUT_ITERATIONS=24  # 5 seconds * 24 iterations = 120 seconds
          COUNTER=0

          while [ $COUNTER -lt $TIMEOUT_ITERATIONS ]; do
              LOG_OUTPUT=$(ecs-cli logs --task-id $TASK_ID --container-name migrate --cluster-config prodigy_cluster_config 2>&1)
              echo "$LOG_OUTPUT"  # Echo the log output during each iteration
              
              # Check the log for the desired pattern
              if echo "$LOG_OUTPUT" | grep -E "Applied [0-9]+ migration[s]?"; then
                  SUCCESS_LOG_FOUND=1
                  break
              fi
              
              sleep 5
              COUNTER=$((COUNTER+1))
          done

          # If the desired log output wasn't found within the timeout, fail the script
          if [ $SUCCESS_LOG_FOUND -eq 0 ]; then
              echo "Failed to find the success log output within 120 seconds."
              exit 1
          fi

          # Loop to keep checking the task status once it's RUNNING
          TASK_STATUS="RUNNING"
          MAX_ITERATIONS=10
          COUNTER=0
          EXIT_CODE=""

          while [ "$TASK_STATUS" != "STOPPED" ] && [ $COUNTER -lt $MAX_ITERATIONS ]; do
              echo "Waiting for the task to complete..."
              sleep 5
              PS_OUTPUT=$(ecs-cli ps --cluster-config prodigy_cluster_config | grep $TASK_ID | grep "migrate")
              echo $PS_OUTPUT
              
              # Check if 'ExitCode' is present in the output
              if echo "$PS_OUTPUT" | grep -q "ExitCode"; then
                  EXIT_CODE=$(echo $PS_OUTPUT | awk -F'ExitCode: ' '{print $2}' | awk '{print $1}')
                  echo "Task Exit Code: $EXIT_CODE"
                  break
              fi
              
              TASK_STATUS=$(echo $PS_OUTPUT | awk '{print $4}')
              echo "Current task status: $TASK_STATUS"
              COUNTER=$((COUNTER+1))
          done

          # the task is done at this point

          # Check if the loop exited because of the max iterations without detecting ExitCode
          if [ $COUNTER -eq $MAX_ITERATIONS ] && [ -z "$EXIT_CODE" ]; then
              echo "Reached maximum iterations without detecting an ExitCode."
              exit 1
          fi

deploy-web: &deploy-web
  <<: *docker-container
  steps:
    - <<: *restore-cache
    - <<: *ecs-cli-configure
    - run:
        name: Deploy web to ECS fargate
        command: |
          ecs-cli compose \
            --debug \
            --project-name web \
            --file docker-compose-ecs-web.yml \
            --ecs-params ecs-params-${ENV}-web.yml \
            service up \
            --cluster-config prodigy_cluster_config \
            --deployment-max-percent 200 \
            --deployment-min-healthy-percent 100 \
            --health-check-grace-period 600 \
            --target-group-arn ${TARGET_GROUP_ARN} \
            --container-name web \
            --container-port 80 \
            --create-log-groups \
            --timeout 15 \
            --force-deployment

